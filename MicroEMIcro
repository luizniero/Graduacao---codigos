list p=16F873A

;Bloco com declarações de variaveis nos locais de memória, para não ter que ficar trabalhando com endereços no código
indf		equ	00h
pcl			equ 02h
status		equ 03h
fsr			equ 04h
porta		equ 05h
trisa		equ	05h
portb		equ	06h
trisb		equ	06h
cont		equ	40h
aux1		equ 41h
aux2		equ 42h
trocou		equ 43h



org 00  ;programa começa aqui

;Bloco que diz às portas como elas irão trabalhar
start
	bsf status,5		;Seleciona banco 1
    movlw B'01111111'	;Reg. W recebe 1 	
    movwf trisa 		;Porta A passa a trabalhar com Seeeeeee (e = entrada, s = saida)
    movlw B'00000000'	;Reg. W recebe 0
    movwf trisb			;Porta B passa a trbalhar somente com SAÍDA
    bcf status,5 		;Seleciona banco 0

	
;Entrada de dados                         e sempre que eu escrever indf seria como escrever memória[fsr]

	movlw 20h
	movwf fsr			; FSR = 20h
	movlw D'5'
	movwf cont
	
LoopInput	
	movlw 	porta 		; valor da porta A vai para W
	movwf 	indf		; MEMORIA[fsr] recebe valor da porta
	clrf 	porta		; limpo porta
	incf	fsr,01h		; pulo para o proximo endereco da memoria, para continuar armazenando os valores
	decfsz	cont, 01h 	;Decremento o contador.  Se for igual a zero, terminou a entrada (pula a prox se conta= 0)
	goto 	LoopInput 	;Volto para Loop para ler o prox valor de entrada
	goto	bubble		; Enquanto contador não for zero, continua no loop
	
bubble
	movlw 00h; w = 0 = false
    movwf trocou; trocou = false
    movlw D'5' ;w = 32 
    movwf cont; cont = w = 32
    movlw 20h; w = 20h
    movwf fsr; fsr = w = 20h
	
	
LoopBubble 
	movlw indf; w = mem[fsr]
    movwf aux1; aux1 = w
    incf fsr,01h;; fsr++ (fsr')
    movlw indf; w = mem[fsr']
    movwf aux2; aux2 = w
    decfsz cont,01h; cont-- (pula próxima se cont for 0)
    goto comparar; comparar(aux1,aux2)
    goto fim; fim()
;
comparar
	movfw aux1; w = aux1
    subwf aux2; aux2 = aux2 - w = aux2 - aux1
    btfss status,0; aux1>aux2? (pula se bit de carry for 0)
    goto troca; sim -> troca()
    ;não, segue
    goto LoopBubble; volta ao inicio
;
troca

	movlw B'11111111'; w = 255
    movwf trocou; trocou = 255 = true
    movfw indf; w = mem[fsr']
    movwf aux2; aux2 = w = mem[fsr']
    decf fsr,01h; fsr'-- (fsr)
    movfw aux2; w = aux2
    movwf indf; mem[fsr] = w = aux2
    incf fsr,01h; fsr++ (fsr')
    movfw aux1; w = aux1
    movwf indf; mem[fsr'] = w = aux1
    ;fsr' -> fsr
    goto LoopBubble; volta para o loop
;
;   
fim btfsc trocou,0; ocorreu troca? (pula se bit 0 de troca não está setado)
    goto bubble; sim (verifica vetor novamente)
    ;não ocorreu (vetor está ordenado)
    end
;
 
Imprime
	movlw 20h
	movwf fsr
	movlw D'32'
	movwf cont

LoopImpress
	movlw 	indf 		; pego o memoria[fsr] e coloco em w
	movlw	portb		; jogo o valor em portb para ser impresso
	clr		portb		; após isso, limpo a porta banco
	incf	fsr, 01h	; pulo para  o proximo endereco da memoria, para continuar imprimindo os valores em portb
	decfsz	cont, 01h ; ;Decremento o contador.  Se for igual a zero, a saída, e, portando, o programa.
	goto LoopImpress			; pula esta linha se for igual a zero, senão, continua imprimindo
	end
